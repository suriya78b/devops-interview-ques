# Ansible
## 1. A user-creation playbook always shows “changed” and is not idempotent. How do you fix it?
If a user-creation playbook always shows "changed" and lacks idempotency, it's likely because you're using raw commands (e.g., via the shell or command module like useradd) instead of Ansible's built-in user module. To fix it, refactor the playbook to use the user module, which is inherently idempotent—it checks if the user already exists with the specified parameters (e.g., name, groups, shell) and only makes changes if needed. Example:
```
- name: Create user
  user:
    name: "{{ username }}"
    state: present
    groups: "{{ user_groups }}"
```
This ensures the task reports "ok" on subsequent runs if no changes are required.

## 2. The AWS dynamic inventory is showing outdated EC2 host details. How do you troubleshoot this?
To troubleshoot outdated EC2 host details in AWS dynamic inventory:
- Check for caching: The dynamic inventory script (e.g., ec2.py) caches results. Use the --refresh-cache flag when running the inventory script or playbook (e.g., ansible-inventory -i ec2.py --refresh-cache).
- Verify AWS credentials: Ensure your AWS access key, secret key, and region are correctly set in environment variables or the boto config file, and that they have sufficient permissions (e.g., EC2 read access).
- Update dependencies: Confirm you're using the latest boto or boto3 library (via pip), as outdated versions may not fetch current data.
- Test the script standalone: Run ec2.py --list or ec2.py --host <hostname> to see raw output and compare against the AWS console.
- Check filters/tags: Ensure your inventory script's filters (e.g., regions, tags) match current EC2 instances; misconfigurations can exclude new hosts.
- Network issues: Verify connectivity to AWS APIs; use tools like aws ec2 describe-instances to test.

## 3. Explain diff between a static and dynamic inventory
A static inventory is a simple file (e.g., INI or YAML format) where hosts and groups are manually defined and don't change automatically. It's straightforward but requires manual updates for dynamic environments. A dynamic inventory, on the other hand, is generated by a script or plugin (e.g., for AWS, Azure, or VMware) that pulls real-time data from external sources like cloud providers. It's ideal for scalable, changing infrastructures as it auto-discovers hosts, but it requires setup and can be more complex to debug.

## 4. Explain group vars and host vars and how you would use them?
Group vars are variables defined for a group of hosts (e.g., in group_vars/web_servers.yml), applying the same values to all members of that group, such as shared configurations like NTP servers or app versions. Host vars are variables specific to an individual host (e.g., in host_vars/host1.yml), overriding group vars for unique settings like IP addresses or host-specific paths. You'd use group vars for consistency across similar hosts (e.g., all database servers use the same DB port), and host vars for overrides (e.g., one host needs a different memory limit due to hardware differences). They can be stored in inventory directories or as separate files.


## 5. Explain variable precedence and cite an example or two
Variable precedence in Ansible determines which variable value wins when the same name is defined in multiple places. The order (from lowest to highest priority) includes: inventory file/group vars, playbook vars, extra vars from command line (-e). For example:
If web_port is set to 80 in group_vars, but you override it to 8080 in the playbook's vars section, the playbook value wins.
Command-line extra vars always override everything: ansible-playbook play.yml -e "web_port=443" would set it to 443 regardless of other definitions. This allows flexibility, like using defaults in code but overriding for specific runs (e.g., prod vs staging environments).


## 6. Explain template vs copy and why you would use one over the other
The template module copies a file from the control node to the remote host while rendering Jinja2 templates (e.g., replacing variables like {{ var_name }}), making it dynamic. The copy module simply copies a static file without any processing. Use template when the file needs customization based on variables (e.g., generating a config file with host-specific IPs or ports, like an Nginx conf). Use copy for unchanged files (e.g., binaries or static scripts) to avoid unnecessary overhead. Template also supports validation to prevent deploying broken configs.


## 7. Explain how roles work and how you go about deciding when to make use them
Roles in Ansible are reusable, self-contained directories bundling tasks, handlers, vars, files, templates, and meta info (e.g., in roles/myrole/tasks/main.yml). They promote modularity and DRY principles. To decide when to use them: If a set of tasks is repeated across playbooks or projects (e.g., installing Nginx, setting up users), extract it into a role for reuse. Start simple in a playbook, then refactor into a role once it's stable. Use ansible-galaxy to create or install roles. Apply them in playbooks via the roles keyword, passing vars as needed for customization.

## 8. Explain how you used loop/with* in playbooks and why
Loops in playbooks (using loop or the deprecated with_* like with_items) allow repeating a task over a list of items, reducing duplication. For example, I've used loop to install multiple packages:
```
- name: Install packages
  package:
    name: "{{ item }}"
    state: present
  loop:
    - nginx
    - mysql
    - php
```
Why: It makes playbooks concise and scalable—easier to manage lists of users, files, or services without copying tasks. with_items was common in older versions but is replaced by loop for better features like combining with filters.

## 9. Explain the diff between include and import, how you may use one over the other
include is dynamic—it evaluates and includes tasks/files at runtime, allowing conditionals or loops on the include itself (e.g., include_tasks: file.yml when: condition). import is static—parsed at load time, so it's faster but can't be conditional on the import statement. Use include for runtime flexibility (e.g., including different task files based on facts like OS type). Use import for performance in large playbooks where static inclusion is fine (e.g., importing vars or plays that always apply). Note: In Ansible 2.4+, import_tasks and include_tasks clarify this, with include being more flexible but potentially slower.

## 10. How you handle secrets in ansible
Handle secrets in Ansible using Ansible Vault: Encrypt sensitive files (e.g., vars files with passwords) via ansible-vault create/edit/view and a vault password file. Reference them in playbooks with vars_files or include them encrypted. For runtime, use --vault-id or --ask-vault-pass when running playbooks. Alternatives include integrating with secret managers like HashiCorp Vault or AWS Secrets Manager via lookup plugins, or environment variables for less sensitive data. Always avoid committing unencrypted secrets to version control.

## 11. what is connection modes, how become works and what is collections?
Connection modes refer to how Ansible connects to hosts: ssh (default, secure remote), local (runs on control node, no remote connection), paramiko (SSH alternative), or others like winrm for Windows. 

become enables privilege escalation (e.g., sudo): Set become: yes in plays/tasks, with methods like become_method: sudo and user/password if needed—it runs tasks as root or another user without manual intervention. 

Collections are shareable packages (via Ansible Galaxy) containing plugins, modules, roles, and playbooks (e.g., community.general for extras), allowing modular extension of Ansible without core changes. Install with ansible-galaxy collection install.
